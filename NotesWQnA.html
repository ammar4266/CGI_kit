<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BITM3213 MASTER NOTES (Complete Edition)</title>
    <style>
        /* --- MAIN LAYOUT STYLES --- */
        :root {
            --primary: #4f46e5;
            --accent: #f59e0b;
            --danger: #dc2626;
            --success: #16a34a;
            --bg: #f8fafc;
            --text: #1e293b;
            --code-bg: #0f172a;
            --sidebar-bg: #ffffff;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* SIDEBAR NAVIGATION */
        nav {
            width: 320px;
            background: var(--sidebar-bg);
            border-right: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            flex-shrink: 0;
            overflow-y: auto;
        }

        .brand {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 2rem;
            text-align: center;
            border-bottom: 2px solid #f1f5f9;
            padding-bottom: 1rem;
        }

        .nav-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: #94a3b8;
            font-weight: bold;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            padding-left: 0.5rem;
        }

        .nav-btn {
            background: none;
            border: none;
            text-align: left;
            padding: 0.9rem 1rem;
            cursor: pointer;
            border-radius: 8px;
            margin-bottom: 0.3rem;
            color: #475569;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 0.9rem;
            display: block;
            width: 100%;
        }

        .nav-btn:hover { background: #eff6ff; color: var(--primary); }
        .nav-btn.active { background: var(--primary); color: white; box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2); }

        /* SPECIAL BUTTONS */
        .nav-btn.strategy-btn {
            background: #fef2f2;
            color: var(--danger);
            border: 1px solid #fecaca;
            font-weight: 800;
        }
        .nav-btn.strategy-btn.active { background: var(--danger); color: white; border-color: var(--danger); }

        .nav-btn.ans-btn {
            background: #f0fdf4;
            color: var(--success);
            border: 1px solid #bbf7d0;
            font-weight: 800;
            margin-top: 10px;
        }
        .nav-btn.ans-btn.active { background: var(--success); color: white; border-color: var(--success); }

        /* MAIN CONTENT AREA */
        main {
            flex: 1;
            padding: 0;
            overflow-y: auto;
            scroll-behavior: smooth;
            background: #f8fafc;
        }

        section {
            display: none;
            max-width: 1000px;
            margin: 0 auto;
            padding: 4rem 5rem;
            animation: fadeIn 0.3s ease-out;
            padding-bottom: 8rem;
        }
        section.active { display: block; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* TYPOGRAPHY */
        h1 { font-size: 2.8rem; border-bottom: 5px solid var(--accent); display: inline-block; margin-bottom: 1.5rem; color: #0f172a; line-height: 1.1; }
        .topic-header { font-size: 1.2rem; color: #64748b; font-style: italic; margin-bottom: 3rem; border-left: 4px solid #cbd5e1; padding-left: 15px; }
        
        h2 { color: var(--primary); margin-top: 4rem; border-left: 6px solid var(--primary); padding-left: 1.2rem; font-size: 1.8rem; }
        h3 { font-weight: 700; margin-top: 2.5rem; color: #334155; font-size: 1.4rem; }
        
        p, li { line-height: 1.8; font-size: 1.05rem; margin-bottom: 1.2rem; }
        
        /* CONTENT BOXES */
        .rojak-box {
            background: #fffbeb;
            border: 1px solid #fcd34d;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 2rem 0;
            color: #78350f;
            position: relative;
        }
        .rojak-box::before { content: "üí° ROJAK EXPLANATION"; font-size: 0.7rem; font-weight: bold; background: #f59e0b; color: white; padding: 2px 8px; border-radius: 4px; position: absolute; top: -10px; left: 15px; }
        
        .slide-box {
            background: #eff6ff; /* Blue Tint */
            border: 2px solid #3b82f6;
            padding: 2rem;
            border-radius: 8px;
            margin: 2.5rem 0;
            position: relative;
        }
        .slide-box::after {
            content: "üìò FROM SLIDES";
            position: absolute;
            top: -14px;
            right: 25px;
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .def-box {
            background: white;
            border-left: 5px solid #3b82f6;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 0 8px 8px 0;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }
        .def-title { font-weight: bold; color: #1d4ed8; margin-bottom: 0.8rem; display: block; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 0.5px; }

        /* IMAGE CONTAINERS */
        .img-container {
            text-align: center;
            margin: 2.5rem 0;
            border: 3px solid #1e293b;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
        }
        .img-container img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        .img-caption {
            background: #1e293b;
            color: #fff;
            padding: 12px;
            font-size: 0.95rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* TABLES */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        .data-table th { background: #1e293b; color: white; padding: 15px; text-align: left; font-size: 0.95rem; text-transform: uppercase; letter-spacing: 1px; }
        .data-table td { border-bottom: 1px solid #e2e8f0; padding: 15px; vertical-align: top; }
        .data-table tr:last-child td { border-bottom: none; }
        .data-table tr:nth-child(even) { background: #f8fafc; }

        /* CODE BLOCKS */
        pre {
            background: var(--code-bg);
            color: #e2e8f0;
            padding: 2rem;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
            margin: 2rem 0;
            font-size: 0.95rem;
            line-height: 1.6;
            border: 1px solid #334155;
        }
        .code-comment { color: #6a9955; font-style: italic; }
        .code-highlight { color: #fbbf24; font-weight: bold; }

        /* EXAM STRATEGY */
        .step-container { display: flex; flex-direction: column; gap: 1.5rem; margin: 3rem 0; }
        .step { display: flex; align-items: flex-start; background: #ffffff; padding: 2rem; border-radius: 12px; border: 1px solid #e2e8f0; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); }
        .step-num { background: var(--danger); color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 1.5rem; flex-shrink: 0; font-size: 1.2rem; }
        .step-content strong { display: block; color: #1e293b; font-size: 1.2rem; margin-bottom: 0.8rem; }
        
        .reveal-box { margin-top: 3rem; border: 3px dashed #cbd5e1; padding: 10px; border-radius: 12px; position: relative; background: #f1f5f9; min-height: 150px; }
        .reveal-content { filter: blur(12px); transition: filter 0.5s; background: white; padding: 3rem; border-radius: 8px; opacity: 0.5; }
        .reveal-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--primary); color: white; border: none; padding: 15px 30px; border-radius: 50px; cursor: pointer; font-weight: bold; z-index: 10; box-shadow: 0 10px 25px rgba(79, 70, 229, 0.4); font-size: 1.1rem; transition: transform 0.2s; }
        .reveal-btn:hover { transform: translate(-50%, -50%) scale(1.05); }
        .reveal-box.active .reveal-content { filter: blur(0); opacity: 1; }
        .reveal-box.active .reveal-btn { display: none; }

        /* ANSWER SCHEME SCOPE */
        #ans-scheme .container { max-width: 900px; margin: 0 auto; background: white; padding: 60px; border-top: 12px solid #1e293b; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); }
        #ans-scheme h1 { text-align: center; border-bottom: 2px solid #000; padding-bottom: 30px; margin-bottom: 50px; font-family: 'Times New Roman', serif; color: black; }
        #ans-scheme .ans-box { background: #f0fdf4; border-left: 6px solid #166534; padding: 20px; font-family: Arial, sans-serif; margin-bottom: 1.5rem; }
        #ans-scheme .ans-label { color: #166534; font-weight: bold; text-transform: uppercase; display: block; margin-bottom: 10px; font-size: 0.9rem; }
        #ans-scheme .question-block { border-bottom: 1px dashed #cbd5e1; padding-bottom: 30px; margin-bottom: 30px; }
        #ans-scheme .q-text { font-size: 1.1rem; font-weight: bold; color: #000; margin-bottom: 15px; font-family: 'Times New Roman', serif; }

    </style>
</head>
<body>

<nav>
    <div class="brand">CG MASTER-kit<br><span>Ammar Edition</span></div>
    
    
    <button class="nav-btn active" onclick="show('ch1')">CH 1: Visual Pipeline</button>
    <button class="nav-btn" onclick="show('ch2')">CH 2: Hardware & 3D Gasket</button>
    <button class="nav-btn" onclick="show('ch3')">CH 3: Geometry & Math</button>
    
    
    <button class="nav-btn" onclick="show('ch4')">CH 4: Input & Interaction</button>
    <button class="nav-btn" onclick="show('ch5')">CH 5: Viewing & Textures</button>
    <button class="nav-btn" onclick="show('ch6')">CH 6: Lighting</button>
    <button class="nav-btn" onclick="show('ch7')">CH 7: Collision</button>

    <div class="nav-label">üî• Exam Strategy</div>
    <button class="nav-btn strategy-btn" onclick="show('strat-sword')">‚öîÔ∏è Q3: Sword Logic</button>
    <button class="nav-btn strategy-btn" onclick="show('strat-draw')">‚úèÔ∏è Q2: Drawing Logic</button>
    <button class="nav-btn ans-btn" onclick="show('ans-scheme')">‚úÖ Full Answer Scheme 23/24</button>
</nav>

<main>

    <section id="ch1" class="active">
        <h1>CHAPTER 1: INTRO & PIPELINE</h1>
        <div class="topic-header">Priority 1: Understanding how data becomes an image.</div>

        <div class="slide-box">
            <h3>1.1 The Visual Pipeline (Must Memorize Order)</h3>
            <p>From the slides, this is the <strong>most critical flow</strong> you need to know first. It explains the 5 stages of how graphics work.</p>
            <table class="data-table">
                <thead>
                    <tr>
                        <th style="width: 15%;">Stage</th>
                        <th style="width: 45%;">What Happens</th>
                        <th style="width: 40%;">Example Visual</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>1. Vertex Processing</strong></td>
                        <td>The positions of points (vertices) are calculated and transformed from 3D world to camera view.</td>
                        <td>Wireframe cube showing vertex points.</td>
                    </tr>
                    <tr>
                        <td><strong>2. Clipping</strong></td>
                        <td>Objects outside the camera‚Äôs view are removed.</td>
                        <td>Camera frustum cutting off part of cube.</td>
                    </tr>
                    <tr>
                        <td><strong>3. Rasterization</strong></td>
                        <td>Converts shapes into tiny pixels (fragments).</td>
                        <td>Zoom-in view of triangles ‚Üí pixels.</td>
                    </tr>
                    <tr>
                        <td><strong>4. Fragment Processing</strong></td>
                        <td>Each pixel gets its color, texture, and lighting.</td>
                        <td>Same cube with color + light.</td>
                    </tr>
                    <tr>
                        <td><strong>5. Framebuffer</strong></td>
                        <td>Final 2D image stored in memory & shown on screen.</td>
                        <td>Finished rendered scene.</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <h2>1.2 Core Definitions</h2>
        <div class="def-box">
            <span class="def-title">Computer Graphics (CG)</span>
            <strong>Proses Synthesis (Creation).</strong> Kita ada Data (nombor/coding), kita create jadi Gambar.<br>
            <strong>Input:</strong> Data/Description.<br>
            <strong>Output:</strong> Image.<br>
            <em>Contoh:</em> Video game, movie CGI (Avatar), lukis plan rumah (CAD).
        </div>

        <div class="def-box">
            <span class="def-title">Image Processing (IP)</span>
            <strong>Proses Analysis (Manipulation).</strong> Kita ada Gambar, kita edit atau extract info.<br>
            <strong>Input:</strong> Image.<br>
            <strong>Output:</strong> Image (edited) atau Data.<br>
            <em>Contoh:</em> Photoshop, filter Instagram, X-Ray hospital, AI detect muka.
        </div>

        <h2>1.3 System Components</h2>
        <p>Satu sistem grafik lengkap kena ada 4 benda ni:</p>
        <ul>
            <li><strong>Input Devices:</strong> Mouse, keyboard, tablet.</li>
            <li><strong>Processor:</strong> CPU + GPU (Graphics Processing Unit).</li>
            <li><strong>Memory:</strong> Framebuffer (VRAM).</li>
            <li><strong>Output:</strong> Monitor/Display (CRT, LCD).</li>
        </ul>
    </section>

    <section id="ch2">
        <h1>CHAPTER 2: HARDWARE & PRIMITIVES</h1>
        <div class="topic-header">Priority 2: How to write the basic code structure.</div>

        <div class="slide-box">
            <h3>2.1 The Standard GLUT Template</h3>
            <p>You cannot write OpenGL code without this skeleton. Memorize the <code>main</code> function structure.</p>
            <pre>
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;GL/glut.h&gt;

// The Drawing Function
void draw() {
    glClear(GL_COLOR_BUFFER_BIT); // 1. Wipe the slate clean
    glLoadIdentity();             // 2. Reset coordinate system
    
    // 3. Define Shapes (e.g., A White Square)
    glBegin(GL_POLYGON);
       glVertex2i(1, 1); // Bottom-Left
       glVertex2i(3, 1); // Bottom-Right
       glVertex2i(3, 3); // Top-Right
       glVertex2i(1, 3); // Top-Left
    glEnd();
    
    glFlush(); // 4. Send command to GPU immediately
}

// The Setup Function
int main(int argc, char* argv) {
    glutInit(&argc, argv);                 // Initialize GLUT
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA); // Set Single Buffer + Colors
    glutCreateWindow("whitesquare");       // Create Window with Title
    glutDisplayFunc(draw);                 // Tell GLUT: "Use this function to draw"
    glutMainLoop();                        // Enter Infinite Loop
}</pre>
        </div>

        <div class="slide-box">
            <h3>2.2 GLUT Function Table (Memorize This)</h3>
            <table class="data-table">
                <tr><th>Function</th><th>Role</th></tr>
                <tr><td><code>glutInit</code></td><td>Initialize GLUT library.</td></tr>
                <tr><td><code>glutInitDisplayMode</code></td><td>Set display options (Single/Double Buffer, RGB Color).</td></tr>
                <tr><td><code>glutInitWindowSize</code></td><td>Set initial window width & height.</td></tr>
                <tr><td><code>glutCreateWindow</code></td><td>Create the window.</td></tr>
                <tr><td><code>glutDisplayFunc</code></td><td>Register the callback function for rendering.</td></tr>
                <tr><td><code>glutMainLoop</code></td><td>Start the event processing loop (Never returns).</td></tr>
            </table>
        </div>

        <h2>2.3 Raster vs Random Scan</h2>
        <div class="rojak-box">
            <strong>Raster Scan (Moden):</strong><br>
            Electron beam sapu satu skrin dari atas ke bawah, baris demi baris (Zig-zag).<br>
            <em>Kelebihan:</em> Boleh buat shading lawa, warna penuh. Murah.<br>
            <em>Simpanan:</em> Guna Frame Buffer.
        </div>
        <div class="rojak-box">
            <strong>Random Scan (Lama/Vector):</strong><br>
            Beam gerak bebas macam pen. Dia lukis garisan je (Point A ke Point B).<br>
            <em>Kelebihan:</em> Garisan sangat licin (takde pixel pecah).<br>
            <em>Kekurangan:</em> Tak boleh warna penuh (wireframe je). Mahal.
        </div>

        <h2>2.4 Frame Buffer Calculation</h2>
        <p><strong>Formula:</strong> <code>Width x Height x BitDepth</code></p>
        <p><em>Contoh:</em> 1024x1024, 24-bit color.</p>
        <ul>
            <li>$1024 \times 1024 \times 24 = 25,165,824$ bits.</li>
            <li>Bahagi 8 (untuk dapat Byte) = $3,145,728$ bytes.</li>
            <li>Bahagi 1024 dua kali (untuk dapat MB) = <strong>3 MB</strong>.</li>
        </ul>

        <div class="slide-box" style="margin-top: 4rem;">
            <h3>2.5 The 3D Gasket (Sierpinski Tetrahedron)</h3>
            <p>From your slides, the <strong>3D Gasket</strong> is a complex object built using simple <strong>recursion</strong>.</p>
            
            <div class="img-container">
                <div class="img-caption">The 3D Gasket Construction</div>
                
                <img src="gasket_demo.jpg" alt="3D Gasket Recursion">
            </div>

            <p><strong>How it works (The Algorithm):</strong></p>
            <ul>
                <li><strong>Step 1 (Base):</strong> Start with a single Tetrahedron (4 vertices).</li>
                <li><strong>Step 2 (Subdivide):</strong> Find the midpoint of every edge.</li>
                <li><strong>Step 3 (Connect):</strong> Connect the midpoints to form 4 smaller tetrahedrons at the corners.</li>
                <li><strong>Step 4 (Remove):</strong> Remove the volume in the very center (The empty space).</li>
                <li><strong>Step 5 (Recurse):</strong> Repeat this process for the 4 new smaller tetrahedrons.</li>
            </ul>
        </div>
    </section>

    <section id="ch3">
        <h1>CHAPTER 3: GEOMETRY & TRANSFORMATION</h1>
        <div class="topic-header">Priority 3: Moving objects in 3D space.</div>

        <div class="slide-box">
            <h3>3.1 Reflection via Scaling (The Trick)</h3>
            <p>OpenGL doesn't have a `glReflect`. We use Scaling with negative numbers to mirror objects.</p>
            
            <div class="img-container">
                <div class="img-caption">Reflection by Scaling (-0.5, 1.0, 1.0)</div>
                <img src="reflection_demo.jpg" alt="Reflection Graph">
            </div>

            <p><strong>Example:</strong> <code>glScalef(-0.5, 1.0, 1.0)</code></p>
            <ul>
                <li><strong>- (Negative X):</strong> Flips the object across the Y-axis (Reflection).</li>
                <li><strong>0.5:</strong> Shrinks the width by half (Compression).</li>
                <li><strong>1.0:</strong> Leaves Height and Depth alone.</li>
            </ul>
        </div>

        <div class="slide-box">
            <h3>3.2 Building a Mesh (The Cube Method)</h3>
            <p>Instead of listing 24 vertices manually, we define 8 unique vertices and link them using <strong>Faces (Quads)</strong>.</p>
            <pre>
// 1. Define 8 Corners of a Cube (0 to 7)
vertices[8] = { v0, v1, v2, v3, v4, v5, v6, v7 };

// 2. Define Faces by Index (Counter-Clockwise)
void colorcube() {
    quad(0, 3, 2, 1); // Front Face
    quad(2, 3, 7, 6); // Right Face
    quad(0, 4, 7, 3); // Bottom Face
    quad(1, 2, 6, 5); // Top Face
    quad(4, 5, 6, 7); // Back Face
    quad(0, 1, 5, 4); // Left Face
}</pre>
            <div class="rojak-box">
                <strong>Why Counter-Clockwise?</strong><br>
                Supaya OpenGL tahu mana "Luar" dan mana "Dalam". Kalau salah order, lighting akan jadi terbalik (gelap kat luar, cerah kat dalam).
            </div>
        </div>

        <h2>3.3 The Big 3 Transformations (TRS)</h2>
        <ul>
            <li><strong>Translation:</strong> <code>glTranslatef(x, y, z)</code> - Gerak/Alih objek.</li>
            <li><strong>Rotation:</strong> <code>glRotatef(angle, x, y, z)</code> - Pusing objek. Guna formula <em>Cos/Sin</em>.</li>
            <li><strong>Scaling:</strong> <code>glScalef(x, y, z)</code> - Besar/Kecilkan objek.</li>
        </ul>

        <h2>3.4 Matrix Order (Critical!)</h2>
        <p>OpenGL baca coding dari <strong>BAWAH ke ATAS</strong>.</p>
        
        <div class="img-container">
            <div class="img-caption">VISUAL CASE STUDY: TRANSFORMATION ORDER</div>
            <img src="transformation_demo.jpg" alt="Transformation Order Demo (Red/Green/Blue Squares)">
            <div style="background:#222; color:#ccc; padding:15px; font-size:0.9rem; text-align:left;">
                <strong>Analysis:</strong><br>
                1. <strong>GREEN (Center):</strong> No code. Base position.<br>
                2. <strong>BLUE (Top Right):</strong> <code>Orbit</code>. Code: <code>glRotate</code> (Top) -> <code>glTranslate</code> (Bottom). Translate runs first (moves out), then Rotate swings it around the center.<br>
                3. <strong>RED (Bottom Left):</strong> <code>Spin & Move</code>. Code: <code>glTranslate</code> (Top) -> <code>glRotate</code> (Bottom). Rotate runs first (spins in place), then Translate moves it sideways.
            </div>
        </div>

        <div class="def-box">
            <span class="def-title">Situasi A: Orbit</span>
            <strong>Logic:</strong> Gerak jauh dulu, baru pusing dunia.
            <pre>glRotatef(...);    // 2. Rotate World
glTranslatef(...); // 1. Push Object Out</pre>
        </div>
        <div class="def-box">
            <span class="def-title">Situasi B: Spin</span>
            <strong>Logic:</strong> Pusing setempat, baru gerak.
            <pre>glTranslatef(...); // 2. Move to location
glRotatef(...);    // 1. Spin in place</pre>
        </div>
    </section>

    <section id="ch4">
        <h1>CHAPTER 4: INPUT & INTERACTION</h1>
        <div class="topic-header">Let's Talk to Our Computer: How Input & Interaction Really Works!</div>

        <div class="slide-box">
            <h3>4.1 Input vs Interaction</h3>
            <p><strong>Input:</strong> How humans talk to the computer. (e.g., Moving the mouse).<br>
            <strong>Interaction:</strong> How the computer responds back. (e.g., Computer moves the cursor).</p>
            <p>It is a two-way conversation between you and your program.</p>
        </div>

        <div class="slide-box">
            <h3>4.2 Physical vs Logical Input</h3>
            <p><strong>Physical Devices:</strong> The hardware (Mouse, Keyboard, Joystick, Touchscreen).</p>
            <p><strong>Logical Input:</strong> What the code actually sees (Numbers/Data). The device type doesn't matter to the code.</p>
            <div class="rojak-box">
                <strong>Analogy:</strong>
                User tekan keyboard 'A', atau user tekan button 'A' kat gamepad.
                Untuk code, dua-dua ni cuma bagi signal <code>input = 'A'</code>. Code tak kisah datang dari mana.
            </div>
            <pre>
// C++ Example
cin >> x; 
// Code waits for an 'int', doesn't care if you typed it or pasted it.
            </pre>
        </div>

        <div class="slide-box">
            <h3>4.3 Graphical Input Types (The Big Table)</h3>
            <table class="data-table">
                <tr><th>Type</th><th>What It Returns</th><th>Example</th></tr>
                <tr><td><strong>Locator</strong></td><td>Position (x,y)</td><td>Mouse pointer, Touchscreen.</td></tr>
                <tr><td><strong>Pick</strong></td><td>Object ID</td><td>Selecting a 3D cube in a scene.</td></tr>
                <tr><td><strong>Keyboard</strong></td><td>Strings/Chars</td><td>Typing a name.</td></tr>
                <tr><td><strong>Stroke</strong></td><td>Array of points</td><td>Drawing a line (Freehand).</td></tr>
                <tr><td><strong>Valuator</strong></td><td>Float number</td><td>Slider value, Joystick tilt.</td></tr>
                <tr><td><strong>Choice</strong></td><td>One of n items</td><td>Menu selection, Button click.</td></tr>
            </table>
        </div>

        <div class="slide-box">
            <h3>4.4 Input Modes</h3>
            <ul>
                <li><strong>Request Mode:</strong> The program pauses and waits until user does something. (Like `cin >> x`). "Press key to continue..."</li>
                <li><strong>Event Mode (GLUT uses this):</strong> The program runs in a loop and *listens*. It reacts instantly when an event happens. "Move mouse anytime, I'll respond!"</li>
            </ul>
        </div>

        <div class="slide-box">
            <h3>4.5 The GLUT Event Loop</h3>
            <p>The core of interaction. <code>glutMainLoop()</code> puts the program into an infinite listening mode.</p>
            <p><strong>It keeps checking:</strong> Mouse moves? Key pressed? Window resized? <br>
            When an event happens, it calls a <strong>Trigger</strong> (The event) and reads the <strong>Measure</strong> (The data).</p>
        </div>

        <h2>4.6 Callback Functions (The Nervous System)</h2>
        <p>Callbacks tell GLUT <em>what to do</em> for each specific event. You "register" them in `main`.</p>

        <div class="def-box">
            <span class="def-title">1. Display Callback</span>
            <code>glutDisplayFunc(draw);</code><br>
            Called when the window opens or needs updating. Use <code>glutPostRedisplay()</code> to force a refresh (like in animation).
        </div>

        <div class="def-box">
            <span class="def-title">2. Mouse Callback (Clicking)</span>
            <code>glutMouseFunc(mymouse);</code><br>
            <pre>
void mymouse(int button, int state, int x, int y) {
    if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
        exit(0); // Right click to quit
    
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
        drawSquare(x, y); // Left click to draw
}</pre>
        </div>

        <div class="def-box">
            <span class="def-title">3. Motion Callback (Dragging)</span>
            <code>glutMotionFunc(drawSquare);</code><br>
            Draw while dragging the mouse with button held down.
        </div>

        <div class="def-box">
            <span class="def-title">4. Keyboard Callback</span>
            <code>glutKeyboardFunc(mykey);</code><br>
            For ASCII keys (a, b, space, enter).
            <pre>if (key == 'q' || key == 'Q') exit(0); // Press Q to quit</pre>
            
            <strong>Special Keys:</strong><br>
            <code>glutSpecialFunc(myspecial);</code> For Arrows, F1-F12.
            <pre>if (key == GLUT_KEY_UP) moveForward();</pre>
        </div>

        <div class="def-box">
            <span class="def-title">5. Idle Callback (Animation)</span>
            <code>glutIdleFunc(myidle);</code><br>
            Runs when there are NO other events. Used for auto-animation.
            <pre>
void myidle() {
    angle += 0.1; // Increase rotation automatically
    glutPostRedisplay(); // Tell display to re-draw
}</pre>
        </div>

        <div class="def-box">
            <span class="def-title">6. Reshape Callback</span>
            <code>glutReshapeFunc(myreshape);</code><br>
            Called when window size changes. We must adjust the <strong>Viewport</strong> so the drawing doesn't get stretched.
            <pre>
void myreshape(int w, int h) {
    glViewport(0, 0, w, h); // Adjust visual area
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(...); // Reset coordinate aspect ratio
}</pre>
        </div>

        <h2>4.7 Double Buffering (Crucial for Animation)</h2>
        <div class="img-container">
            <div class="img-caption">Visual Logic: Single vs Double Buffer</div>
            <img src="buffer_demo.jpg" alt="Double Buffering Diagram">
        </div>
        <p><strong>Single Buffer:</strong> Draws directly to the screen. User sees the drawing process. Result: <strong>Flickering</strong>.</p>
        <p><strong>Double Buffer:</strong> Has two canvases (Front & Back).</p>
        <ul>
            <li><strong>Back Buffer:</strong> Where the computer draws (Hidden).</li>
            <li><strong>Front Buffer:</strong> What the user sees (Visible).</li>
        </ul>
        <p><strong>Process:</strong> Draw to Back -> Call <code>glutSwapBuffers()</code> -> Back becomes Front instantly. Result: <strong>Smooth Animation</strong>.</p>
    </section>

    <section id="ch5">
        <h1>CHAPTER 5: VIEWING & TEXTURE MAPPING</h1>
        <div class="topic-header">From Camera Angles to Realistic Skins</div>

        <h2>Part A: Viewing (The Camera)</h2>
        <p>Viewing is the process of showing 3D objects on a 2D screen. It involves the <strong>Object</strong>, the <strong>Viewer (Camera)</strong>, and the <strong>Projection Surface</strong>.</p>

        <div class="slide-box">
            <h3>1. Types of Projections</h3>
            
            <div class="img-container">
                <div class="img-caption">Visualizing Parallel vs Perspective Projections</div>
                <img src="projection_demo.jpg" alt="Projection Types Diagram">
            </div>

            <table class="data-table">
                <tr>
                    <th>Parallel Projection</th>
                    <th>Perspective Projection</th>
                </tr>
                <tr>
                    <td>Lines remain parallel. No depth perception.</td>
                    <td>Lines converge at vanishing points. Objects far away look smaller.</td>
                </tr>
                <tr>
                    <td><strong>Types:</strong>
                        <ul>
                            <li><strong>Orthographic:</strong> Top, Front, Right Side.</li>
                            <li><strong>Axonometric:</strong> Isometric (120¬∞), Dimetric, Trimetric.</li>
                            <li><strong>Oblique:</strong> Cavalier (Full depth), Cabinet (Half depth).</li>
                        </ul>
                    </td>
                    <td><strong>Types:</strong> 1-Point, 2-Point, 3-Point Perspective.</td>
                </tr>
                <tr>
                    <td><strong>Pros:</strong> Accurate measurements (Engineering/Blueprint).</td>
                    <td><strong>Pros:</strong> Realistic, immersive (Games/Movies).</td>
                </tr>
            </table>
        </div>

        <div class="def-box">
            <span class="def-title">Parallel Types Detail</span>
            <ul>
                <li><strong>Orthographic:</strong> Top, Front, Right Side views.</li>
                <li><strong>Axonometric:</strong> Showing multiple sides at once.
                    <ul>
                        <li><strong>Isometric:</strong> 3 Equal axes/angles (Standard game view).</li>
                        <li><strong>Dimetric:</strong> 2 Equal axes.</li>
                        <li><strong>Trimetric:</strong> 0 Equal axes.</li>
                    </ul>
                </li>
                <li><strong>Oblique:</strong> Projectors are at an angle.
                    <ul>
                        <li><strong>Cavalier:</strong> Full depth scale.</li>
                        <li><strong>Cabinet:</strong> Half depth scale (More realistic).</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="slide-box">
            <h3>2. OpenGL Viewing Functions</h3>
            <p><strong>Camera Position:</strong> <code>gluLookAt(eyeX, eyeY, eyeZ, atX, atY, atZ, upX, upY, upZ)</code></p>
            <ul>
                <li><strong>Eye:</strong> Where is the camera?</li>
                <li><strong>At:</strong> What is it looking at?</li>
                <li><strong>Up:</strong> Which way is "up" for the camera?</li>
            </ul>

            <p><strong>Projection Setup:</strong></p>
            <ul>
                <li><code>glFrustum(left, right, bottom, top, near, far)</code>: Manual pyramid setup. Hard to use.</li>
                <li><code>gluPerspective(fovy, aspect, zNear, zFar)</code>: Easy setup.
                    <ul>
                        <li><strong>fovy:</strong> Field of View (e.g., 60 degrees).</li>
                        <li><strong>aspect:</strong> Width / Height.</li>
                        <li><strong>zNear/zFar:</strong> Render distance limits.</li>
                    </ul>
                </li>
            </ul>
        </div>

        <h2>Part B: Texture Mapping (The Skin)</h2>
        <p>Applying an image (bitmap) to a 3D surface to add detail without adding more polygons.</p>

        <div class="slide-box">
            <h3>1. Coordinate System</h3>
            <p>Textures use <strong>(s, t)</strong> or <strong>(u, v)</strong> coordinates ranging from <strong>0 to 1</strong>.</p>
            <ul>
                <li>(0,0) = Bottom Left of image.</li>
                <li>(1,1) = Top Right of image.</li>
            </ul>
            <p><strong>Mapping Types:</strong> Cylindrical (Cans), Spherical (Planets), Box (Crates).</p>
        </div>

        <div class="slide-box">
            <h3>2. OpenGL Texture Steps (Must Know)</h3>
            <ol>
                <li><strong>Enable:</strong> <code>glEnable(GL_TEXTURE_2D);</code></li>
                <li><strong>Load:</strong> <code>glTexImage2D(...);</code> (Load the bitmap data).</li>
                <li><strong>Set Parameters:</strong> Wrapping and Filtering.</li>
                <li><strong>Draw:</strong> Map texture to vertex using <code>glTexCoord2f(s, t); glVertex3f(x, y, z);</code></li>
            </ol>
        </div>

        <div class="def-box">
            <span class="def-title">Wrapping Modes (What happens at the edge?)</span>
            <ul>
                <li><code>GL_REPEAT</code>: Tiles the image (Default). Good for floors/walls.</li>
                <li><code>GL_MIRRORED_REPEAT</code>: Tiles but flips every other one.</li>
                <li><code>GL_CLAMP_TO_EDGE</code>: Stretches the last pixel. Good for skyboxes.</li>
                <li><code>GL_CLAMP_TO_BORDER</code>: Uses a solid color border.</li>
            </ul>
        </div>

        <div class="def-box">
            <span class="def-title">Filtering & Mipmapping</span>
            <p><strong>Filtering (Zooming):</strong></p>
            <ul>
                <li><code>GL_NEAREST</code>: Pixelated (Minecraft style). Fast.</li>
                <li><code>GL_LINEAR</code>: Blurry/Smooth. High quality.</li>
            </ul>
            <p><strong>Mipmapping:</strong> Stores smaller versions of the texture (128x, 64x, 32x...) to use when the object is far away. Prevents <strong>shimmering</strong> and saves memory bandwidth.</p>
        </div>
    </section>

    <section id="ch6">
        <h1>CHAPTER 6: LIGHTING & SHADING</h1>
        <div class="topic-header">Physics of Light, Illumination Models, and Shading.</div>

        <div class="slide-box">
            <h3>1. The Physics of Light</h3>
            <p>Light is what allows us to perceive the world. In CG, it controls brightness, color, and mood.</p>
            
            <div class="img-container">
                <div class="img-caption">Physical Properties of Light</div>
                

[Image of Light Wave Properties]

                <img src="light_properties.jpg" alt="Wavelength vs Amplitude Diagram">
            </div>

            <ul>
                <li><strong>Wavelength:</strong> Determines the color (long = red, short = blue).</li>
                <li><strong>Amplitude:</strong> Determines the brightness or intensity.</li>
                <li><strong>Speed:</strong> Constant in vacuum, slower in materials due to refraction.</li>
                <li><strong>Photon Count:</strong> More photons per unit time increase perceived brightness.</li>
            </ul>
        </div>

        <div class="slide-box">
            <h3>2. Color Models in Graphics</h3>
            <div class="img-container">
                <div class="img-caption">Color Models (RGB vs CMYK)</div>
                

[Image of Additive vs Subtractive Color Mixing]

                <img src="color_models.jpg" alt="RGB and CMYK Venn Diagrams">
            </div>
            
            <table class="data-table">
                <tr>
                    <th>RGB (Additive)</th>
                    <th>CMYK (Subtractive)</th>
                    <th>HSV/HSL (Artistic)</th>
                </tr>
                <tr>
                    <td>Used in screens and OpenGL. Colors created by ADDING light.</td>
                    <td>Used in printing. Colors form by ABSORBING wavelengths.</td>
                    <td>Useful for artistic control (Hue, Saturation, Value).</td>
                </tr>
            </table>
            <p><em>Understanding these models helps achieve accurate rendering and color representation.</em></p>
        </div>

        <div class="slide-box">
            <h3>3. Illumination Models: Local vs Global</h3>
            <p><strong>Local Illumination (OpenGL Standard):</strong> Fast. Calculates light only based on direct line of sight from light source to object. No shadows, no reflection between objects.</p>
            <p><strong>Global Illumination (Ray Tracing):</strong> Slow but realistic. Calculates light bouncing between objects (inter-reflection), soft shadows, and color bleeding.</p>
            
            <div class="img-container">
                <div class="img-caption">Classic vs Modern Lighting</div>
                <img src="classic_modern.jpg" alt="Comparison between Classic OpenGL and Modern PBR Lighting">
            </div>
        </div>

        <div class="slide-box">
            <h3>4. Perception: What Lighting Defines</h3>
            <ul>
                <li><strong>Shape:</strong> Through shading (diffuse response).</li>
                <li><strong>Material:</strong> Through specular behavior (shiny vs matte).</li>
                <li><strong>Scene Depth:</strong> Using highlights and shadows.</li>
                <li><strong>Mood:</strong> Bright = cheerful, Dark = tense.</li>
                <li><strong>Immersion:</strong> By combining all lighting cues.</li>
            </ul>
        </div>

        <div class="slide-box">
            <h3>5. The Classic OpenGL Lighting Model (Phong)</h3>
            <p>A simplified model to approximate reality using 4 components:</p>
            
            <div class="img-container">
                <div class="img-caption">The 4 Components of Phong Lighting</div>
                
                <img src="phong_components.jpg" alt="Ambient Diffuse Specular Emission Spheres">
            </div>

            <div class="def-box">
                <span class="def-title">A. Ambient Light</span>
                <p>Base global light. Ensures scene isn't pitch black.</p>
            </div>

            <div class="def-box">
                <span class="def-title">B. Diffuse Reflection</span>
                <p>Light scattered from surface. Defines main color and shape.</p>
            </div>

            <div class="def-box">
                <span class="def-title">C. Specular Reflection</span>
                <p>Shiny highlights. Defines material smoothness.</p>
            </div>

            <div class="def-box">
                <span class="def-title">D. Emission</span>
                <p>Self-lit materials. Object glows but doesn't light up others.</p>
            </div>
        </div>

        <div class="slide-box">
            <h3>6. OpenGL Implementation Code</h3>
            
            <div class="img-container">
                <div class="img-caption">Quick Guide to OpenGL Lighting Code</div>
                <img src="opengl_guide.jpg" alt="Code snippet guide for OpenGL lighting">
            </div>

            <pre>
void initLight() {
    glEnable(GL_LIGHTING); // Master switch
    glEnable(GL_LIGHT0);   // Turn on Light 0

    // 1. Define Light Properties
    GLfloat light_pos[] = {1.0, 1.0, 1.0, 0.0}; // Directional
    GLfloat white_light[] = {1.0, 1.0, 1.0, 1.0};
    glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, white_light);

    // 2. Define Material Properties (The Object)
    GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};
    GLfloat mat_shininess[] = {50.0}; // High value = Metal
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}</pre>
            <div class="rojak-box">
                <strong>IMPORTANT: Normals</strong><br>
                Lighting requires Normals (`glNormal3f`). If you don't define them, OpenGL doesn't know where the surface is facing, and lighting will fail (object looks flat/dark).
            </div>
        </div>
    </section>

    <section id="ch7">
        <h1>CHAPTER 7: COLLISION DETECTION</h1>
        <div class="topic-header">Detecting Hits & Optimizing Performance</div>

        <div class="slide-box">
            <h3>7.1 The Collision Pipeline</h3>
            <div class="img-container">
                <div class="img-caption">Detection vs Response</div>
                
                <img src="collision_pipeline.jpg" alt="Collision Detection Process Flow">
            </div>
            <p><strong>Detection:</strong> "Did they hit?" (The What & Where).<br>
            <strong>Response:</strong> "What happens next?" (Bounce, Stop, Explode).</p>
        </div>

        <div class="slide-box">
            <h3>7.2 Bounding Volumes (The Proxies)</h3>
            <p>We wrap complex meshes (1000s of triangles) in simple shapes to check collision quickly.</p>
            <div class="img-container">
                <div class="img-caption">Bounding Volume Types</div>
                <img src="bounding_volumes.jpg" alt="Sphere AABB OBB Capsule ConvexHull">
            </div>
            <table class="data-table">
                <tr><th>Type</th><th>Description</th><th>Pros</th><th>Cons</th></tr>
                <tr><td><strong>Sphere</strong></td><td>Radius from a center point.</td><td>Fastest math (Distance squared). Rotational invariant.</td><td>Bad fit for long/flat objects.</td></tr>
                <tr><td><strong>AABB</strong></td><td>Axis-Aligned Bounding Box. Min/Max X,Y,Z.</td><td>Very fast. Easy to construct.</td><td>Loose fit if object rotates (box grows).</td></tr>
                <tr><td><strong>OBB</strong></td><td>Oriented Bounding Box. Box that rotates with object.</td><td>Tighter fit than AABB.</td><td>Complex math (Separating Axis Theorem).</td></tr>
                <tr><td><strong>Capsule</strong></td><td>Cylinder with half-spheres.</td><td>Perfect for humanoid characters.</td><td>Slightly more expensive than Sphere.</td></tr>
                <tr><td><strong>Convex Hull</strong></td><td>"Shrink wrap" around the object.</td><td>Tightest fit possible.</td><td>Most expensive to calculate.</td></tr>
            </table>
        </div>

        <div class="slide-box">
            <h3>7.3 Optimization: Spatial Partitioning</h3>
            <p><strong>The Problem:</strong> Checking every object against every other object is $O(N^2)$. If you have 1000 objects, that's 1,000,000 checks!</p>
            <p><strong>The Solution:</strong> Divide the world. Only check objects near each other.</p>
            
            <div class="img-container">
                <div class="img-caption">Spatial Subdivision (Grid / Octree)</div>
                
                <img src="spatial_grid.jpg" alt="Grid Division Diagram">
            </div>

            <div class="def-box">
                <span class="def-title">1. Uniform Grid</span>
                Divide world into equal squares. Easy math. Good for open fields. Bad if objects clump together.
            </div>
            
            <div class="def-box">
                <span class="def-title">2. Quadtree (2D) / Octree (3D)</span>
                Recursive division. If a square has too many objects, split it into 4 smaller squares.
                <br><strong>Pros:</strong> Adaptive detail (more boxes where needed).
                <br><strong>Cons:</strong> Complex to update moving objects.
            </div>

            <div class="def-box">
                <span class="def-title">3. BVH (Bounding Volume Hierarchy)</span>
                A tree of boxes. A big box wraps two smaller boxes, which wrap the objects.
                <br>If you miss the big box, you skip everything inside it.
            </div>
        </div>

        <div class="rojak-box">
            <strong>The Tunneling Effect</strong><br>
            If a bullet moves too fast, it might skip completely over a thin wall in one frame.
            <br><em>Fix:</em> Use <strong>Ray Casting</strong> (draw a line) instead of just checking position.
            <div class="img-container">
                <div class="img-caption">Tunneling Effect</div>
                <img src="tunneling.jpg" alt="Object skipping detection">
            </div>
        </div>
    </section>

    <section id="strat-sword">
        <h1>Exam Strategy: The Sword Question</h1>
        <div class="topic-intro">Soalan Past Year suruh complete code untuk lukis pedang. Jangan hafal code buta-buta. Ini cara "Think Like a GPU".</div>

        <div class="step-container">
            <div class="step">
                <div class="step-num">1</div>
                <div class="step-content">
                    <strong>Lukis Pemegang Dulu (Base)</strong>
                    <p>Kita start dengan objek utama. Dalam soalan ni, dia guna <code>glutWireDodecahedron</code>. Ini pusat dunia kita sekarang.</p>
                </div>
            </div>
            <div class="step">
                <div class="step-num">2</div>
                <div class="step-content">
                    <strong>Freeze Location (glPushMatrix)</strong>
                    <p>Sekarang kita nak lukis Bilah. Tapi kita tak nak kacau posisi Pemegang. So kita tekan butang "Save" (Push).</p>
                </div>
            </div>
            <div class="step">
                <div class="step-num">3</div>
                <div class="step-content">
                    <strong>Pindah ke Hujung Pemegang (Translate)</strong>
                    <p>Kita gerakkan "Pen" kita ke atas pemegang (Translate), supaya bilah pedang tu bersambung cantik.</p>
                </div>
            </div>
            <div class="step">
                <div class="step-num">4</div>
                <div class="step-content">
                    <strong>Lukis Bilah (Draw Child)</strong>
                    <p>Sekarang baru lukis bilah tu. Tukar warna merah dulu (glColor), lepastu lukis bentuknya.</p>
                </div>
            </div>
            <div class="step">
                <div class="step-num">5</div>
                <div class="step-content">
                    <strong>Unfreeze (glPopMatrix)</strong>
                    <p>Dah siap lukis bilah, kita tekan "Load" (Pop) untuk balik ke posisi asal.</p>
                </div>
            </div>
        </div>

        <div class="reveal-box">
            <button class="reveal-btn" onclick="reveal(this)">Reveal Code Answer</button>
            <div class="reveal-content">
                <h3>Isi Tempat Kosong (a-j):</h3>
                <pre>
void displayMe(void) {
   (a) glClearColor(0,0,0,1);     <span class="code-comment">// Background Hitam</span>
   (b) glClear(...);              <span class="code-comment">// Cuci Skrin</span>
   (c) gluLookAt(...);            <span class="code-comment">// Setup Kamera</span>
   (d) glColor3f(1.0, 1.0, 1.0);  <span class="code-comment">// Warna Putih (Pemegang)</span>

   <span class="code-highlight">(e) glPushMatrix();</span>            <span class="code-comment">// STEP 2: Save Matrix</span>
   
   (g) glRotated(65, 1, 0, 0);    <span class="code-comment">// Pusing sikit guard tu</span>
   (h) glutWireDodecahedron();    <span class="code-comment">// STEP 1: Lukis Pemegang</span>

   (f) glPopMatrix();             <span class="code-comment">// (Nota: Dalam soalan ni dia pop awal)</span>

   <span class="code-comment">// ... Bahagian Bilah ...</span>
   
   (i) glColor3f(1.0, 0.0, 0.0);  <span class="code-comment">// Warna Merah (Bilah)</span>
   
   (j) glutSwapBuffers();         <span class="code-comment">// Final step: Tunjuk kat skrin</span>
}</pre>
            </div>
        </div>
    </section>

    <section id="strat-draw">
        <h1>Exam Strategy: Drawing Shapes</h1>
        <div class="topic-intro">Soalan: "Draw a Rectangle with a Triangle on top". Fahamkan koordinat kertas graf.</div>

        <div class="step-container">
            <div class="step">
                <div class="step-num">A</div>
                <div class="step-content">
                    <strong>Design the Base (GL_QUADS)</strong>
                    <p>Start dari (0,0) -> (0.5, 0) -> (0.5, 0.5) -> (0, 0.5). Pusing ikut lawan jam (Counter-Clockwise).</p>
                </div>
            </div>
            <div class="step">
                <div class="step-num">B</div>
                <div class="step-content">
                    <strong>Design the Roof (GL_TRIANGLES)</strong>
                    <p>Tapak segitiga ialah Bumbung kotak tadi. So koordinat y=0.5. Puncak kena tinggi lagi, so y=0.75.</p>
                </div>
            </div>
        </div>

        <div class="reveal-box">
            <button class="reveal-btn" onclick="reveal(this)">Reveal Code Solution</button>
            <div class="reveal-content">
<pre>
glBegin(GL_QUADS);  <span class="code-comment">// Lukis Kotak</span>
   glVertex3f(0.0, 0.0, 0.0);
   glVertex3f(0.5, 0.0, 0.0);
   glVertex3f(0.5, 0.5, 0.0); <span class="code-comment">// Top Right</span>
   glVertex3f(0.0, 0.5, 0.0); <span class="code-comment">// Top Left</span>
glEnd();

glBegin(GL_TRIANGLES); <span class="code-comment">// Lukis Bumbung</span>
   glVertex3f(0.25, 0.75, 0.0); <span class="code-comment">// Puncak (Tengah)</span>
   glVertex3f(0.5, 0.5, 0.0);   <span class="code-comment">// Kaki Kanan</span>
   glVertex3f(0.0, 0.5, 0.0);   <span class="code-comment">// Kaki Kiri</span>
glEnd();
</pre>
            </div>
        </div>
    </section>

    <section id="ans-scheme">
        <div id="ans-scheme-container">
            <div class="paper-container">
                <h1>BITM3213: Final Exam Solution<br><span style="font-size:1rem; font-weight:normal;">Full Marking Scheme (100 Marks)</span></h1>

                <div class="section-title">QUESTION 1 (30 MARKS)</div>

                <div class="question-block">
                    <div class="q-text">a. Define SIX (6) major elements of a computer graphics system. [6 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <ol>
                            <li><strong>Input Devices:</strong> Tools to send data/commands (e.g., Mouse, Keyboard, Tablet).</li>
                            <li><strong>Processor:</strong> The processing units that calculate geometry and pixel data (CPU & GPU).</li>
                            <li><strong>Memory:</strong> System memory (RAM) for storing application data.</li>
                            <li><strong>Frame Buffer:</strong> Specialized video memory (VRAM) that stores the final image pixels before display.</li>
                            <li><strong>Output Devices:</strong> Hardware to display the result (e.g., CRT, LCD Monitor, Projector).</li>
                            <li><strong>Software:</strong> The graphics APIs (OpenGL) and application code.</li>
                        </ol>
                    </div>
                    <div class="teacher-note">
                        <strong>üë®‚Äçüè´ Teacher's Note:</strong> 
                        List je 6 point ni. Kalau lupa "Software", boleh letak "Bus System" (kabel dalam PC) pun kadang-kadang diterima. Tapi <strong>Input, Output, Processor, Framebuffer</strong> tu wajib ada.
                    </div>
                </div>

                <div class="question-block">
                    <div class="q-text">b. Explain in detail the major steps in the Geometric Pipeline (Vertex Processor, Clipper, Rasterizer, Fragment Processor). [16 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <ul>
                            <li><strong>Vertex Processor:</strong> 
                                <br>Takes 3D vertex data (coordinates) and transforms them from Object Space into Clip Space (Screen coordinates). It also handles vertex lighting calculations.
                            </li>
                            <li><strong>Clipper & Primitive Assembler:</strong> 
                                <br><em>Primitive Assembly:</em> Connects vertices to form shapes (triangles/lines).
                                <br><em>Clipper:</em> Removes (clips) parts of the geometry that fall outside the camera's view frustum so they are not processed further.
                            </li>
                            <li><strong>Rasterizer:</strong> 
                                <br>Converts the continuous mathematical shapes (vectors) into discrete fragments (potential pixels) that align with the screen grid.
                            </li>
                            <li><strong>Fragment Processor:</strong> 
                                <br>Calculates the final color for each fragment. It applies texture mapping, lighting (per-pixel), and performs visibility tests (Z-buffer check).
                            </li>
                        </ul>
                    </div>
                    <div class="teacher-note">
                        <strong>üë®‚Äçüè´ Teacher's Note:</strong> 
                        Markah banyak (16m)! So setiap point kena ada <strong>Input</strong> (apa dia terima) dan <strong>Output</strong> (apa dia buat).
                        <br>Example: Rasterizer = Terima Shape -> Keluar Pixel.
                    </div>
                </div>

                <div class="question-block">
                    <div class="q-text">c. State TWO (2) differences between Raster Graphics and Vector Graphics. [8 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <table border="1" cellpadding="5" style="border-collapse:collapse; width:100%;">
                            <tr>
                                <th>Aspect</th>
                                <th>Raster Graphics</th>
                                <th>Vector Graphics</th>
                            </tr>
                            <tr>
                                <td><strong>Composition</strong></td>
                                <td>Composed of a grid of pixels (Bitmap).</td>
                                <td>Composed of mathematical paths (lines/curves).</td>
                            </tr>
                            <tr>
                                <td><strong>Scalability</strong></td>
                                <td>Quality degrades (pixelates) when zoomed in.</td>
                                <td>Scales infinitely without loss of quality.</td>
                            </tr>
                        </table>
                    </div>
                </div>


                <div class="section-title">QUESTION 2 (30 MARKS)</div>

                <div class="question-block">
                    <div class="q-text">a. List and draw FIVE (5) other geometric objects available in OpenGL/GLUT. [15 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <ol>
                            <li><strong>glutSolidCube()</strong> - (Draw a Cube)</li>
                            <li><strong>glutSolidCone()</strong> - (Draw a Cone)</li>
                            <li><strong>glutSolidTorus()</strong> - (Draw a Donut shape)</li>
                            <li><strong>glutSolidTeapot()</strong> - (Draw a Teapot)</li>
                            <li><strong>glutSolidTetrahedron()</strong> - (Draw a Pyramid with 3-sided base)</li>
                        </ol>
                    </div>
                    <div class="teacher-note">
                        <strong>üë®‚Äçüè´ Teacher's Note:</strong> 
                        Dalam kertas exam, lukis bentuk simple kat sebelah nama tu. Kotak, Kon aiskrim, Donut, Teko, Piramid.
                    </div>
                </div>

                <div class="question-block">
                    <div class="q-text">b. Complete the code to draw a Rectangle with a Triangle on top. [9 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
    <pre>
    <span class="keyword">void</span> <span class="func">displayMe</span>(<span class="type">void</span>) {
        <span class="func">glClear</span>(GL_COLOR_BUFFER_BIT);

        <span class="comment">// -- (i) Draw Rectangle --</span>
        <span class="func">glBegin</span>(<span class="keyword">GL_QUADS</span>); 
            <span class="func">glVertex3f</span>(<span class="num">0.0</span>, <span class="num">0.0</span>, <span class="num">0.0</span>); <span class="comment">// (ii) Bottom Left</span>
            <span class="func">glVertex3f</span>(<span class="num">0.5</span>, <span class="num">0.0</span>, <span class="num">0.0</span>); <span class="comment">// (iii) Bottom Right</span>
            <span class="func">glVertex3f</span>(<span class="num">0.5</span>, <span class="num">0.5</span>, <span class="num">0.0</span>); <span class="comment">// (iv) Top Right</span>
            <span class="func">glVertex3f</span>(<span class="num">0.0</span>, <span class="num">0.5</span>, <span class="num">0.0</span>); <span class="comment">// (v) Top Left</span>
        <span class="func">glEnd</span>();

        <span class="comment">// -- (vi) Draw Triangle --</span>
        <span class="func">glBegin</span>(<span class="keyword">GL_TRIANGLES</span>);
            <span class="func">glVertex3f</span>(<span class="num">0.25</span>, <span class="num">0.75</span>, <span class="num">0.0</span>); <span class="comment">// (vii) Top Peak</span>
            <span class="func">glVertex3f</span>(<span class="num">0.5</span>, <span class="num">0.5</span>, <span class="num">0.0</span>);   <span class="comment">// (viii) Bottom Right</span>
            <span class="func">glVertex3f</span>(<span class="num">0.0</span>, <span class="num">0.5</span>, <span class="num">0.0</span>);   <span class="comment">// (ix) Bottom Left</span>
        <span class="func">glEnd</span>();

        <span class="func">glFlush</span>();
    }</pre>
                    </div>
                    <div class="teacher-note">
                        <strong>üë®‚Äçüè´ Teacher's Note:</strong> 
                        Kunci dia kat coordinate.
                        <br>Segiempat: lebar 0.0 sampai 0.5. Tinggi 0.0 sampai 0.5.
                        <br>Segitiga: Mesti duduk ATAS segiempat. So tapak dia y=0.5. Puncak dia mesti tengah-tengah (x=0.25) dan tinggi sikit (y=0.75).
                    </div>
                </div>

                <div class="question-block">
                    <div class="q-text">c. Difference between Single Buffer and Double Buffer. [6 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <ul>
                            <li><strong>Single Buffer:</strong> The system draws directly to the displayed screen memory. This causes <strong>flickering</strong> as the user can see the drawing process happening.</li>
                            <li><strong>Double Buffer:</strong> Uses two buffers (Front and Back). The system draws on the hidden <strong>Back Buffer</strong>. Once finished, it <strong>swaps</strong> with the Front Buffer instantly. This creates smooth animation.</li>
                        </ul>
                    </div>
                </div>


                <div class="section-title">QUESTION 3 (20 MARKS)</div>

                <div class="question-block">
                    <div class="q-text">Complete the code (Fill in the blanks a-j) for the Sword Transformation.</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer Key:</span>
                        <ul style="list-style: none;">
                            <li><strong>(a) glClearColor</strong> - <em>Sets background color to black (0,0,0,1).</em></li>
                            <li><strong>(b) glClear</strong> - <em>Clears the buffers.</em></li>
                            <li><strong>(c) gluLookAt</strong> - <em>Sets up the camera position (Eye, At, Up).</em></li>
                            <li><strong>(d) glColor3f</strong> - <em>Sets current color to White (1,1,1).</em></li>
                            <li><strong>(e) glPushMatrix</strong> - <em>Saves the matrix before drawing the first part.</em></li>
                            <li><strong>(f) glPopMatrix</strong> - <em>Restores the matrix after drawing.</em></li>
                            <li><strong>(g) glRotated</strong> - <em>Rotates the object (Guard) by 65 degrees.</em></li>
                            <li><strong>(h) glutWireDodecahedron</strong> - <em>Draws the wireframe shape (based on the context of the previous block).</em></li>
                            <li><strong>(i) glColor3f</strong> - <em>Sets current color to Red (1,0,0) for the blade.</em></li>
                            <li><strong>(j) Buffers</strong> - <em>Completes the command `glutSwapBuffers`.</em></li>
                        </ul>
                    </div>
                    <div class="teacher-note">
                        <strong>üë®‚Äçüè´ Teacher's Note:</strong> 
                        Soalan ni test kefahaman korang pasal <strong>Matrix Stack</strong>.
                        Setiap kali nampak `glTranslated` yang diikuti lukisan, mesti diaapit oleh `glPushMatrix` (atas) dan `glPopMatrix` (bawah) supaya pergerakan tu tak kacau objek lain.
                    </div>
                </div>


                <div class="section-title">QUESTION 4 (20 MARKS)</div>

                <div class="question-block">
                    <div class="q-text">a. Discuss Hierarchical AABBs (HAABB) concepts and advantages. [4 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <p><strong>Concept:</strong> A tree structure where a large root Bounding Box encapsulates the entire object, and smaller boxes (children) encapsulate specific sub-parts.</p>
                        <p><strong>Advantage:</strong> <strong>Efficiency</strong>. Collision detection starts at the root. If the root box is not hit, the system skips checking all the smaller child boxes, saving significant computational power.</p>
                    </div>
                </div>

                <div class="question-block">
                    <div class="q-text">b. Methods to construct hierarchies (Octree vs Quadtree). [4 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <ul>
                            <li><strong>Quadtree (2D):</strong> Recursively divides a 2D space into 4 equal quadrants. Used for 2D maps or terrain.</li>
                            <li><strong>Octree (3D):</strong> Recursively divides a 3D volume into 8 equal octants (cubes). Used for partitioning 3D game worlds to organize objects spatially.</li>
                        </ul>
                    </div>
                </div>

                <div class="question-block">
                    <div class="q-text">c. Trade-offs and Dynamic Updates. [6 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <p><strong>Trade-offs:</strong> <br>
                        AABBs are fast to calculate but have a "loose fit" (lots of empty space). OBBs have a "tight fit" but are computationally expensive. Deep hierarchies (like deep Octrees) save collision time but consume more <strong>Memory</strong>.</p>
                        <p><strong>Dynamic Updates:</strong> <br>
                        When objects move or rotate, static AABBs become invalid. The hierarchy must be <strong>Refitted</strong> (resized) or <strong>Rebuilt</strong> each frame. This is expensive. A common strategy is to use "Loose Octrees" where boxes are slightly larger than needed to allow small movements without immediate updates.</p>
                    </div>
                </div>

                <div class="question-block">
                    <div class="q-text">d. Real-world applications. [6 Marks]</div>
                    <div class="ans-box">
                        <span class="ans-label">Answer:</span>
                        <ol>
                            <li><strong>FPS Games (Hitboxes):</strong> Characters use a hierarchy of boxes (Head, Torso, Arms). The game first checks the "Body Box". If hit, it checks the "Head Box" to detect headshots.</li>
                            <li><strong>Physics Simulations:</strong> Destructible environments (e.g., a wall breaking). The hierarchy allows the engine to simulate physics on individual bricks only when the wall is struck.</li>
                            <li><strong>Visibility Culling:</strong> Using the hierarchy to determine which objects are outside the camera view (Frustum Culling) so they are not rendered.</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </section>

</main>

<script>
    function show(id) {
        document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
        
        const buttons = document.querySelectorAll('.nav-btn');
        for (let btn of buttons) {
            if (btn.getAttribute('onclick') === `show('${id}')`) {
                btn.classList.add('active');
            }
        }
    }
    
    function reveal(btn) {
        btn.parentElement.classList.add('active');
    }
    
    // Default show Strategy
    show('strat-sword');
</script>

</body>
</html>